# This file tests list command on each internal list representation.
#
# Copyright (c) 2025 Ashok P. Nadkarni
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# In Tcl 9, a list may have one of several list representations.
# - "list" - the basic list (similar to 8.6 implementation)
# - "list" with span - basic list with an attached span specifying a
#    contained range.
# - "arithseries" - an abstract list as produced by the lseq command
# - "repeatedList" - an abstract list holding repeated elements
# - "reversedList" - an abstract list that is the reverse of another list
#
# All list operations, loops, {*} expansion need to be tested with each of the
# above types. The first three of these are already tested in cmdIL.test,
# lseq.test, listrep.test etc. but are included here for completeness. Note the
# tests here do not test command options to the commands as those are already
# tested in the aforementioned files.
#
# For the abstract list types not tested elsewhere,
#   - verify constructor commands return the expected type
#   - generated string representations

# Test list operations include combinations of
# - Compiled / uncompiled operation
# - Shared / unshared operands
# - List internal representation types.
#
# TODO - see comments to testlistobj
# TODO - see listobjmemcheck and indexmemcheck in listObj.test
# TODO - lrepeat/lreverse string generation when starting with #
# TODO -lrepeat/lreverse list of braces
# TODO - nested lrepeat with index list and separate indices
# TODO - nested list combinations. Verify none of the lists shimmer
# TODO - [lreverse [lreverse]] should retrieve original list.

if {"::tcltest" ni [namespace children]} {
    package require tcltest 2.5
    namespace import -force ::tcltest::*
}

::tcltest::loadTestedCommands
catch [list package require -exact tcl::test [info patchlevel]]

testConstraint testobj [llength [info commands testobj]]
testConstraint testlistobj [llength [info commands testobj]]

namespace eval listtype {
    variable listTypes {arithseries list repeatedList reversedList spanlist}
    variable nestableTypes {list repeatedList reversedList spanlist}

    # Loop vars etc.
    variable ltype
    variable ltype1
    variable ltype2
    variable ltype3
    variable first
    variable last
    variable indices
    variable result

    # Internal representation produced by a list operation may depend on list
    # length. This is controlled by the *_LENGTH_THRESHOLD values in tclListTypes.c.
    # In cases where it matters, assumes a length of smallListLength will always
    # be less that these thresholds and largeListLength will be greater.
    variable smallListLength 10
    variable largeListLength 1000; # Multiple of 4 because of assumptions in tests

    proc getListType {l} {
        set ltype [testobj objtype $l]
        if {$ltype eq "list"} {
            if {[dict exists [testlistrep describe $l] span]} {
                return "spanlist"
            }
        }
        return $ltype
    }

    # Raise error if list is not the expected type
    proc assertListType {l type} {
        set ltype [getListType $l]
        if {$ltype ne $type} {
            error "Assertion failed: list type was \"$ltype\", expected \"$type\""
        }
    }

    # Returns a list of length $largeListLength of the specified type
    proc makeList {type args} {
        variable largeListLength
        if {[llength $args]} {
            set len [lindex $args 0]
        } else {
            set len $largeListLength
        }
        set l [switch $type {
            list {
                testlistrep new $len
            }
            spanlist {
                # Spanned list - force span by leaving 10 empty slots in front
                testlistrep new $len 10
            }
            arithseries {
                lseq $len
            }
            repeatedList {
                lrepeat [expr {$len/4}] a b c d
            }
            reversedList {
                lreverse [makeList list]
            }
        }]
        assertListType $l $type
        return $l
    }

    # Return first and last elements of a list created with makeList
    # assuming default lengths passed to makeList
    proc getFirstAndLast {ltype} {
        variable largeListLength
        switch $ltype {
            repeatedList {
                set first a
                set last d
            }
            reversedList {
                set last 0
                set first [expr {$largeListLength-1}]
            }
            default {
                set first 0
                set last [expr {$largeListLength-1}]
            }
        }
        return [list $first $last]
    }

    proc makeNestedList {args} {
        variable largeListLength
        set nestedTypes [lassign $args thisType]
        if {[llength $nestedTypes] == 0} {
            return [makeList $thisType]
        }
        set nestedList [makeNestedList {*}$nestedTypes]
        return [switch $thisType {
            list {
                for {set i 0} {$i < $largeListLength} {incr i} {
                    lappend outerList $nestedList
                }
                set outerList
            }
            spanlist {
                for {set i 0} {$i < (1+$largeListLength)} {incr i} {
                    lappend outerList $nestedList
                }
                lrange $outerList 0 end-1
            }
            repeatedList {
                lrepeat $largeListLength $nestedList
            }
            reversedList {
                for {set i 0} {$i < $largeListLength} {incr i} {
                    lappend outerList $nestedList
                }
                lreverse $outerList
            }
            default {
                error "List type $thisType cannot nest"
            }
        }]
    }

    # Verify that list constructors return unshared Tcl_Obj's. Otherwise, unshared
    # list tests below are invalid. These don't actually test Tcl itself, but rather
    # the makeList constructors.
    foreach ltype $listTypes {
        test ltype-verify-unshared-makeList-$ltype "Verify makeList is unshared" -body {
            regexp {refcount of 1,} [tcl::unsupported::representation [makeList $ltype]]
        } -result 1
    }
    foreach ltype1 $nestableTypes {
        foreach ltype2 $nestableTypes {
            foreach ltype3 $listTypes {
                test ltype-verify-makeNestedList-$ltype1-$ltype2-$ltype3 "Verify makeNestedList" -body {
                    set l [makeNestedList $ltype1 $ltype2 $ltype3]
                    list [getListType $l] [getListType [lindex $l 0]] [getListType [lindex $l 0 0]]
                } -result [list $ltype1 $ltype2 $ltype3]
            }
        }
    }

    # Wrapper to generate uncompiled, compiled script, and proc cases for a
    # test. If $args does not contain a -body key, $comment is treated as the
    # test body
    proc testdef {id comment args} {
        if {[dict exists $args -body]} {
            set body [dict get $args -body]
            dict unset args -body
        } else {
            set body $comment
        }
        dict lappend args -constraints testobj

        uplevel 1 [list test $id.uncompiled "$comment (uncompiled)" \
                       -body [list testevalex $body] \
                       {*}$args]

        uplevel 1 [list test $id.compiled-script "$comment (compiled script)" \
                       -body [list try $body] \
                       {*}$args]

        # Need to make namespace variables accessible to test body within proc
        set procbody [string cat \
                      "variable largeListLength\n" \
                      "variable smallListLength\n" \
                      "variable ltype\n" \
                      "variable ltype1\n" \
                      "variable ltype2\n" \
                      "variable ltype3\n" \
                      $body]

        dict append args -setup \n[list proc testxproc {} $procbody]
        dict append args -cleanup "\nrename testxproc {}"
        uplevel 1 [list test $id.proc "$comment (compiled proc)" \
                       -body testxproc \
                       {*}$args]
    }

    # llength
    foreach ltype $listTypes {
        testdef llength-$ltype-shared-0 "llength of shared type $ltype" -body {
            set l [makeList $ltype]
            list [getListType $l] [llength $l]
        } -result [list $ltype $largeListLength]

        testdef llength-$ltype-unshared-0 "llength of unshared type $ltype" -body {
            llength [makeList $ltype]
        } -result $largeListLength
    }

    ################################################################
    # lindex tests - single index
    foreach ltype $listTypes {
        lassign [getFirstAndLast $ltype] first last
        testdef lindex-$ltype-shared-0 "lindex 0 of shared type $ltype" -body {
            set l [makeList $ltype]
            list [getListType $l] [lindex $l 0]
        } -result [list $ltype $first]

        testdef lindex-$ltype-unshared-0 "lindex 0 of unshared type $ltype" -body {
            lindex [makeList $ltype] 0
        } -result $first

        testdef lindex-$ltype-shared-1 "lindex end of shared type $ltype" -body {
            set l [makeList $ltype]
            list [getListType $l] [lindex $l end]
        } -result [list $ltype $last]

        testdef lindex-$ltype-unshared-1 "lindex end of unshared type $ltype" -body {
            lindex [makeList $ltype] end
        } -result $last

        testdef lindex-$ltype-shared-2 "lindex -1 of shared type $ltype" -body {
            set l [makeList $ltype]
            list [getListType $l] [lindex $l -1]
        } -result [list $ltype {}]

        testdef lindex-$ltype-unshared-2 "lindex -1 of unshared type $ltype" -body {
            lindex [makeList $ltype] -1
        } -result {}

        testdef lindex-$ltype-shared-3 "lindex last of shared type $ltype" -body {
            set l [makeList $ltype]
            list [getListType $l] [lindex $l [llength $l]]
        } -result [list $ltype {}]

        testdef lindex-$ltype-unshared-3 "lindex last of unshared type $ltype" -body {
           lindex [makeList $ltype] $largeListLength
        } -result {}

        testdef lindex-$ltype-bad-index "lindex $ltype bad index" -body {
            lindex [makeList $ltype] badindex
        } -result {bad index "badindex": must be integer?[+-]integer? or end?[+-]integer?} -returnCodes error
    }

    # lindex tests - nested indices, both single indices arg and multiple args forms
    foreach ltype1 $nestableTypes {
        foreach ltype2 $nestableTypes {
            foreach ltype3 $listTypes {
                lassign [getFirstAndLast $ltype3] first last
                foreach {indices result} [list \
                                              {0 0 0} $first \
                                              {0 0 end} $last \
                                              {0 0 -1} {} \
                                              [list 0 0 $largeListLength] {} \
                                              {0 -1 0} {} \
                                              [list 0 $largeListLength 0] {} \
                ] {
                    testdef ltype-lindex-nested-onearg-$ltype1-$ltype2-$ltype3 "lindex nested single indices argument $ltype1 $ltype2 $ltype3 $indices" \
                        -body {
                            variable indices
                            lindex [makeNestedList $ltype1 $ltype2 $ltype3] $indices
                        } -result $result

                    testdef ltype-lindex-nested-multiarg-$ltype1-$ltype2-$ltype3 "lindex nested multiple index arguments $ltype1 $ltype2 $ltype3 $indices" \
                        -body {
                            variable indices
                            lindex [makeNestedList $ltype1 $ltype2 $ltype3] {*}$indices
                        } -result $result
                }
            }
        }
    }

    ################################################################
    # lappend tests
    # lappend result is always a non-abstract list. All the tests below do is
    # confirm abstract lists are converted to non-abstract and appended to
    # and further that in the case of shared objects, they are not changed
    # or shimmered.
    # Test variations of lappend (multiple args etc) are not tested here.
    # See listObj.test and listRep.test for those.
    foreach ltype $listTypes {
        testdef lappend-$ltype-unshared "lappend to unshared list of type $ltype " -body {
            set result {}
            set l [makeList $ltype]
            lappend result [getListType $l]
            lappend result [testobj objrefcount $l]; # 2 -> 1 for var l + 1 for arg
            lappend l X
            lappend result [getListType $l]
            lappend result [testobj objrefcount $l]; # 2 -> 1 for var l + 1 for arg
            lappend result [string equal $l [string cat [makeList $ltype] " X"]]
        } -result [list $ltype 2 [expr {$ltype eq "spanlist" ? "spanlist" : "list"}] 2 1]

        testdef lappend-$ltype-shared "lappend to shared list of type $ltype" -body {
            set result {}
            set l [makeList $ltype]
            set l2 $l
            lappend result [getListType $l]
            lappend result [testobj objrefcount $l]; # 3: l, l2, arg
            lappend result [testobj objrefcount $l2]; # ditto
            lappend l X
            lappend result [getListType $l]; # Will be list/spanlist
            lappend result [getListType $l2]; # Should not have changed
            lappend result [testobj objrefcount $l]; # Should drop by 1
            lappend result [testobj objrefcount $l2]; # Should drop by 1
            lappend result [string equal $l [string cat [makeList $ltype] " X"]]
            lappend result [string equal $l2 [makeList $ltype]]
        } -result [list $ltype 3 3 [expr {$ltype eq "spanlist" ? "spanlist" : "list"}] $ltype 2 2 1 1]
    }

    ################################################################
    # lassign tests
    # lassign result is always a spanlist except for arithseries which
    # implements an optimized range operation.
    foreach ltype $listTypes {
    }

    ################################################################
    # ledit tests - TBD
    ################################################################
    # lreplace tests - TBD
    ################################################################
    # linsert tests - TBD
    ################################################################
    # lreverse tests - TBD
    ################################################################
    # lsearch tests - TBD
    ################################################################
    # lset tests - TBD
    ################################################################
    # lsort tests - TBD
    ################################################################
    # foreach tests - TBD
    ################################################################
    # lmap tests - TBD
    ################################################################
    # lrange tests - TBD
    ################################################################
    # concat tests - TBD
    ################################################################
    # join tests - TBD
    ################################################################
    # lrepeat tests - TBD
    ################################################################
    # lpop tests - TBD
    ################################################################
    # lremove tests - TBD



}

# All done
::tcltest::cleanupTests 
