'\"
'\" Copyright (c) 2022 Eric Taylor.  All rights reserved.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\"
.TH lseq n 9.0 Tcl "Tcl Built-In Commands"
.so man.macros
.BS
'\" Note:  do not modify the .SH NAME line immediately below!
.SH NAME
lseq \- Build a numeric sequence returned as a list
.SH SYNOPSIS
.nf
\fBlseq \fIstart end\fR
\fBlseq \fIstart\fR ?\fBto\fR? \fIend\fR ?\fIstepSpec\fR?
\fBlseq \fIstart\fR ?\fB..\fR? \fIend\fR ?\fIstepSpec\fR?
\fBlseq \fIstart \fBcount\fI count\fR ?\fIstepSpec\fR?

\fBlseq \fIcount\fR ?\fBby \fIstepValue\fR?
.fi
.BE
.SH DESCRIPTION
.PP
The \fBlseq\fR command creates a sequence of numeric values using the arguments
\fIstart\fR, \fIend\fR, \fIcount\fR, and optionally
\fIstepSpec\fR/\fIstepValue\fR. 
.PP
If a \fIstart\fR value is specified as the first argument, the \fIend\fR value
of the sequence can be specified as the next argument, optionally preceeded by
the literal word "\fBto\fR" or "\fB..\fR". Alternatively, the \fIcount\fR
(number of elements in the sequence) can be defined instead when preceeded by
the word \fBcount\fR. In both cases, the interval between the subsequent
numbers of the sequence can be specified using the optional \fIstepSpec\fR
argument. It is defined as "?\fBby\fR? \fIstepValue\fR", i.e. the optional word
\fBby\fR followed by the step value.
.PP
A short form use of the command with a single argument \fIcount\fR will create a
sequence from 0 to \fIcount\fR-1. It can optioanlly be followed by a step value
preceeded by the word \fBby\fR.
.PP
The \fBlseq\fR command can produce both increasing and decreasing
sequences. When both \fIstart\fR and \fIend\fR are provided without a
\fIstepValue\fR, then if \fIstart\fR <= \fIend\fR, the sequence will be
increasing and if \fIstart\fR > \fIend\fR it will be decreasing. If the
\fIstepValue\fR is included, it's sign should agree with the direction of the
sequence (descending \(-> negative and ascending \(-> positive), otherwise an
empty list is returned.  For example:
.RS
.PP
.CS \"
% \fBlseq\fR 1 to 5    ;# increasing
\fI\(-> 1 2 3 4 5

% \fBlseq\fR 5 to 1    ;# decreasing
\fI\(-> 5 4 3 2 1

% \fBlseq\fR 6 to 1 by 2   ;# decreasing, step wrong sign, empty list

% \fBlseq\fR 1 to 5 by 0   ;# all step sizes of 0 produce an empty list
.\"
.CE
.RE
.PP
The numeric arguments in \fIstart\fR, \fIend\fR, \fIstepValue\fR and \fIcount\fR
may also be valid expressions. The expression will be evaluated and the
numeric result will be used.  An expression that does not evaluate to a number
will produce an invalid argument error.
.PP
\fIStart\fR defines the initial value and \fIend\fR defines the limit, not
necessarily the last value. \fBlseq\fR produces a list with \fIcount\fR
elements, and if \fIcount\fR is not supplied, it is computed as:
.RS
.PP
.CS
\fIcount\fR = int( (\fIend\fR - \fIstart\fR + \fIstepValue\fR) / \fIstepValueq\fR )
.CE
.RE
.SH EXAMPLES
.CS
.\"
\fBlseq\fR 3
\fI\(-> 0 1 2\fR

\fBlseq\fR 3 0
\fI\(-> 3 2 1 0\fR

\fBlseq\fR 10 .. 1 by -2
\fI\(-> 10 8 6 4 2\fR

set l [\fBlseq\fR 0 -5]
\fI\(-> 0 -1 -2 -3 -4 -5\fR

foreach i [\fBlseq\fR [llength $l]] {
    puts l($i)=[lindex $l $i]
}
\fI\(-> l(0)=0\fR
\fI\(-> l(1)=-1\fR
\fI\(-> l(2)=-2\fR
\fI\(-> l(3)=-3\fR
\fI\(-> l(4)=-4\fR
\fI\(-> l(5)=-5\fR

foreach i [\fBlseq\fR {[llength $l]-1} 0] {
    puts l($i)=[lindex $l $i]
}
\fI\(-> l(5)=-5\fR
\fI\(-> l(4)=-4\fR
\fI\(-> l(3)=-3\fR
\fI\(-> l(2)=-2\fR
\fI\(-> l(1)=-1\fR
\fI\(-> l(0)=0\fR

set i 17
         \fI\(-> 17\fR
if {$i in [\fBlseq\fR 0 50]} { # equivalent to: (0 <= $i && $i <= 50)
    puts "Ok"
} else {
    puts "outside :("
}
\fI\(-> Ok\fR

set sqrs [lmap i [\fBlseq\fR 1 10] { expr {$i*$i} }]
\fI\(-> 1 4 9 16 25 36 49 64 81 100\fR
.\"
.CE
.SH "SEE ALSO"
foreach(n), list(n), lappend(n), lassign(n), lindex(n), linsert(n), llength(n),
lmap(n), lpop(n), lrange(n), lremove(n), lreplace(n),
lreverse(n), lsearch(n), lset(n), lsort(n)
.SH KEYWORDS
element, index, list
'\" Local Variables:
'\" mode: nroff
'\" fill-column: 78
'\" End:
